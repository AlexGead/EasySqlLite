# EasySqlLite
Использование:
1. Подключение класса:
  Просто вставьте код класса SQLiteDatabase в ваш PHP-файл.

2. Создание экземпляра класса:
    $filename = "my_database.sqlite"; // Имя файла базы данных (будет создан, если не существует)
    $logFile = "database_errors.log"; // Имя файла для логирования ошибок (необязательно)
    $db = new SQLiteDatabase($filename, $logFile);
*  $filename: Обязательный аргумент, указывает путь к файлу базы данных SQLite. Если файла не существует, он будет создан.
  •  $logFile: Необязательный аргумент, указывает путь к файлу, в который будут записываться сообщения об ошибках. Если не указан, ошибки будут записываться в стандартный лог ошибок PHP (обычно настраивается в файле php.ini).

3. Создание таблицы:
    $columns = [
        'id' => 'INTEGER PRIMARY KEY AUTOINCREMENT', // Автоматически увеличивающийся первичный ключ
        'name' => 'TEXT NOT NULL', // Текстовое поле, не может быть пустым
        'price' => 'REAL NOT NULL', // Число с плавающей точкой, не может быть пустым
        'quantity' => 'INTEGER', // Целое число
        'email' => 'TEXT' // Текстовое поле для email
    ];
    $db->createTable("products", $columns);
*  $tableName: Имя таблицы, которую нужно создать.
  •  $columns: Ассоциативный массив, определяющий структуру таблицы. Ключ - имя столбца, значение - тип данных SQL. Доступные типы данных: INTEGER, TEXT, REAL, BLOB, NULL.
  •  PRIMARY KEY AUTOINCREMENT: Указывает, что столбец является первичным ключом и автоматически увеличивается при каждой новой записи.

4. Вставка данных:
    $data = [
        'name' => 'Laptop',
        'price' => 1200.00,
        'quantity' => 10,
        'email' => 'test@example.com'
    ];
    $validationRules = [
        'name' => 'required|string', // Обязательное текстовое поле
        'price' => 'required|float|min:0', // Обязательное число с плавающей точкой, не меньше 0
        'quantity' => 'integer|min:0', // Целое число, не меньше 0
        'email' => 'email' // Валидный email адрес
    ];
    $db->set("products", $data, $validationRules);
*  $tableName: Имя таблицы, в которую нужно вставить данные.
  •  $data: Ассоциативный массив, содержащий данные для вставки. Ключ - имя столбца, значение - значение, которое нужно вставить.
  •  $validationRules: Необязательный ассоциативный массив, определяющий правила валидации для каждого поля. Поддерживаемые правила (разделяются символом |):
    *  required: Поле обязательно для заполнения.
    *  string: Поле должно быть строкой.
    *  integer: Поле должно быть целым числом.
    *  float: Поле должно быть числом с плавающей точкой.
    *  min:value: Поле должно быть не меньше value.
    *  max:value: Поле должно быть не больше value.
    *  email: Поле должно быть валидным email адресом.
    *  regex:pattern: Поле должно соответствовать регулярному выражению pattern (например, regex:/^[a-zA-Z]+$/ для поля, состоящего только из букв).

5. Обновление данных:
    $data = [
        'price' => 1250.00 // Новая цена
    ];
    $db->update("products", $data, "name = :name", [':name' => 'Laptop'], ['price' => 'required|float|min:0']);
*  $tableName: Имя таблицы, в которой нужно обновить данные.
  •  $data: Ассоциативный массив, содержащий новые значения для обновления. Ключ - имя столбца, значение - новое значение.
  •  $where: Условие WHERE, определяющее, какие записи нужно обновить. Используйте плейсхолдеры (например, :name) для безопасности.
  •  $bindings: Ассоциативный массив, содержащий значения для подстановки в плейсхолдеры в $where. Ключ - имя плейсхолдера (с двоеточием), значение - значение.
  •  $validationRules: (Необязательный) массив правил валидации для данных, которые собираетесь обновить.

6. Удаление данных:
    $db->delete("products", "name = :name", [':name' => 'Mouse']);
*  $tableName: Имя таблицы, из которой нужно удалить данные.
  •  $where: Условие WHERE, определяющее, какие записи нужно удалить. Используйте плейсхолдеры для безопасности.
  •  $bindings: Ассоциативный массив, содержащий значения для подстановки в плейсхолдеры в $where.

7. Выборка данных:
    // Выборка всех данных из таблицы
    $products = $db->get("products");

    // Выборка данных с условием WHERE
    $product = $db->get("products", "id = :id", [':id' => 1]);

    // Выборка с сортировкой и лимитом
    $expensiveProducts = $db->get("products", null, [], '*', 'price DESC', 2);
*  $tableName: Имя таблицы, из которой нужно выбрать данные.
  •  $where: (Необязательный) Условие WHERE, определяющее, какие записи нужно выбрать. Используйте плейсхолдеры для безопасности. Если не указано, выбираются все записи.
  •  $bindings: (Необязательный) Ассоциативный массив, содержащий значения для подстановки в плейсхолдеры в $where.
  •  $columns: (Необязательный) Список столбцов, которые нужно выбрать. По умолчанию '*' (все столбцы).
  •  $orderBy: (Необязательный) Условие ORDER BY, определяющее порядок сортировки результатов (например, 'price DESC' для сортировки по цене в убывающем порядке).
  •  $limit: (Необязательный) Ограничение на количество возвращаемых записей.

  Результат:

  •  Метод get() возвращает массив ассоциативных массивов. Каждый внутренний массив представляет одну строку из базы данных.
  •  Если произошла ошибка, метод возвращает false.

8. Транзакции:
    $db->beginTransaction();
    try {
        $db->set("products", ['name' => 'Mousepad', 'price' => 15.00, 'quantity' => 100, 'email' => 'mousepad@example.com'], $validationRules);
        $db->update("products", ['quantity' => 25], "name = :name", [':name' => 'Laptop'], $validationRules);
        $db->commitTransaction();
    } catch (Exception $e) {
        $db->rollbackTransaction();
        echo "Транзакция отменена: " . $e->getMessage() . PHP_EOL;
    }
*  beginTransaction(): Начинает транзакцию.
  •  commitTransaction(): Фиксирует транзакцию (сохраняет изменения в базу данных).
  •  rollbackTransaction(): Отменяет транзакцию (откатывает все изменения, сделанные в рамках транзакции).
  •  Транзакции используются для группировки нескольких операций в одну логическую единицу. Если одна из операций не удалась, все изменения, сделанные в рамках транзакции, будут отменены, чтобы обеспечить целостность данных.

9. Удаление таблицы:
    $db->dropTable("products");
*  $tableName: Имя таблицы, которую нужно удалить. Будьте осторожны, эта операция необратима!

10. Закрытие соединения:
    $db->disconnect();
*  Закрывает соединение с базой данных. Хотя PHP автоматически закрывает соединение при завершении скрипта, рекомендуется закрывать его вручную, когда оно больше не нужно, для освобождения ресурсов.

Важные замечания:

•  Безопасность: Всегда используйте подготовленные выражения (prepared statements) с плейсхолдерами и привязкой значений (bindValue()) для защиты от SQL-инъекций. Никогда не подставляйте данные напрямую в SQL-запросы.
•  Валидация: Используйте правила валидации для проверки данных перед вставкой или обновлением, чтобы обеспечить соответствие данных требованиям вашего приложения.
•  Логирование: Настройте логирование ошибок, чтобы можно было отслеживать проблемы с базой данных.
•  Транзакции: Используйте транзакции для группировки нескольких операций, чтобы обеспечить целостность данных.
•  Обработка ошибок: Всегда оборачивайте код, работающий с базой данных, в блоки try...catch, чтобы обрабатывать возможные исключения и предотвращать аварийное завершение скрипта.
•  Типы данных: Будьте внимательны к типам данных, используемым в SQLite. Используйте правильные типы данных для столбцов таблицы и для значений, которые вы вставляете или обновляете.

Этот класс предоставляет удобный и безопасный способ работы с базами данных SQLite в PHP. Следуйте этой инструкции и рекомендациям, чтобы использовать его эффективно и предотвратить возможные проблемы.Использование:
1. Подключение класса:
  Просто вставьте код класса SQLiteDatabase в ваш PHP-файл.

2. Создание экземпляра класса:
    $filename = "my_database.sqlite"; // Имя файла базы данных (будет создан, если не существует)
    $logFile = "database_errors.log"; // Имя файла для логирования ошибок (необязательно)
    $db = new SQLiteDatabase($filename, $logFile);
*  $filename: Обязательный аргумент, указывает путь к файлу базы данных SQLite. Если файла не существует, он будет создан.
  •  $logFile: Необязательный аргумент, указывает путь к файлу, в который будут записываться сообщения об ошибках. Если не указан, ошибки будут записываться в стандартный лог ошибок PHP (обычно настраивается в файле php.ini).

3. Создание таблицы:
    $columns = [
        'id' => 'INTEGER PRIMARY KEY AUTOINCREMENT', // Автоматически увеличивающийся первичный ключ
        'name' => 'TEXT NOT NULL', // Текстовое поле, не может быть пустым
        'price' => 'REAL NOT NULL', // Число с плавающей точкой, не может быть пустым
        'quantity' => 'INTEGER', // Целое число
        'email' => 'TEXT' // Текстовое поле для email
    ];
    $db->createTable("products", $columns);
*  $tableName: Имя таблицы, которую нужно создать.
  •  $columns: Ассоциативный массив, определяющий структуру таблицы. Ключ - имя столбца, значение - тип данных SQL. Доступные типы данных: INTEGER, TEXT, REAL, BLOB, NULL.
  •  PRIMARY KEY AUTOINCREMENT: Указывает, что столбец является первичным ключом и автоматически увеличивается при каждой новой записи.

4. Вставка данных:
    $data = [
        'name' => 'Laptop',
        'price' => 1200.00,
        'quantity' => 10,
        'email' => 'test@example.com'
    ];
    $validationRules = [
        'name' => 'required|string', // Обязательное текстовое поле
        'price' => 'required|float|min:0', // Обязательное число с плавающей точкой, не меньше 0
        'quantity' => 'integer|min:0', // Целое число, не меньше 0
        'email' => 'email' // Валидный email адрес
    ];
    $db->set("products", $data, $validationRules);
*  $tableName: Имя таблицы, в которую нужно вставить данные.
  •  $data: Ассоциативный массив, содержащий данные для вставки. Ключ - имя столбца, значение - значение, которое нужно вставить.
  •  $validationRules: Необязательный ассоциативный массив, определяющий правила валидации для каждого поля. Поддерживаемые правила (разделяются символом |):
    *  required: Поле обязательно для заполнения.
    *  string: Поле должно быть строкой.
    *  integer: Поле должно быть целым числом.
    *  float: Поле должно быть числом с плавающей точкой.
    *  min:value: Поле должно быть не меньше value.
    *  max:value: Поле должно быть не больше value.
    *  email: Поле должно быть валидным email адресом.
    *  regex:pattern: Поле должно соответствовать регулярному выражению pattern (например, regex:/^[a-zA-Z]+$/ для поля, состоящего только из букв).

5. Обновление данных:
    $data = [
        'price' => 1250.00 // Новая цена
    ];
    $db->update("products", $data, "name = :name", [':name' => 'Laptop'], ['price' => 'required|float|min:0']);
*  $tableName: Имя таблицы, в которой нужно обновить данные.
  •  $data: Ассоциативный массив, содержащий новые значения для обновления. Ключ - имя столбца, значение - новое значение.
  •  $where: Условие WHERE, определяющее, какие записи нужно обновить. Используйте плейсхолдеры (например, :name) для безопасности.
  •  $bindings: Ассоциативный массив, содержащий значения для подстановки в плейсхолдеры в $where. Ключ - имя плейсхолдера (с двоеточием), значение - значение.
  •  $validationRules: (Необязательный) массив правил валидации для данных, которые собираетесь обновить.

6. Удаление данных:
    $db->delete("products", "name = :name", [':name' => 'Mouse']);
*  $tableName: Имя таблицы, из которой нужно удалить данные.
  •  $where: Условие WHERE, определяющее, какие записи нужно удалить. Используйте плейсхолдеры для безопасности.
  •  $bindings: Ассоциативный массив, содержащий значения для подстановки в плейсхолдеры в $where.

7. Выборка данных:
    // Выборка всех данных из таблицы
    $products = $db->get("products");

    // Выборка данных с условием WHERE
    $product = $db->get("products", "id = :id", [':id' => 1]);

    // Выборка с сортировкой и лимитом
    $expensiveProducts = $db->get("products", null, [], '*', 'price DESC', 2);
*  $tableName: Имя таблицы, из которой нужно выбрать данные.
  •  $where: (Необязательный) Условие WHERE, определяющее, какие записи нужно выбрать. Используйте плейсхолдеры для безопасности. Если не указано, выбираются все записи.
  •  $bindings: (Необязательный) Ассоциативный массив, содержащий значения для подстановки в плейсхолдеры в $where.
  •  $columns: (Необязательный) Список столбцов, которые нужно выбрать. По умолчанию '*' (все столбцы).
  •  $orderBy: (Необязательный) Условие ORDER BY, определяющее порядок сортировки результатов (например, 'price DESC' для сортировки по цене в убывающем порядке).
  •  $limit: (Необязательный) Ограничение на количество возвращаемых записей.

  Результат:

  •  Метод get() возвращает массив ассоциативных массивов. Каждый внутренний массив представляет одну строку из базы данных.
  •  Если произошла ошибка, метод возвращает false.

8. Транзакции:
    $db->beginTransaction();
    try {
        $db->set("products", ['name' => 'Mousepad', 'price' => 15.00, 'quantity' => 100, 'email' => 'mousepad@example.com'], $validationRules);
        $db->update("products", ['quantity' => 25], "name = :name", [':name' => 'Laptop'], $validationRules);
        $db->commitTransaction();
    } catch (Exception $e) {
        $db->rollbackTransaction();
        echo "Транзакция отменена: " . $e->getMessage() . PHP_EOL;
    }
*  beginTransaction(): Начинает транзакцию.
  •  commitTransaction(): Фиксирует транзакцию (сохраняет изменения в базу данных).
  •  rollbackTransaction(): Отменяет транзакцию (откатывает все изменения, сделанные в рамках транзакции).
  •  Транзакции используются для группировки нескольких операций в одну логическую единицу. Если одна из операций не удалась, все изменения, сделанные в рамках транзакции, будут отменены, чтобы обеспечить целостность данных.

9. Удаление таблицы:
    $db->dropTable("products");
*  $tableName: Имя таблицы, которую нужно удалить. Будьте осторожны, эта операция необратима!

10. Закрытие соединения:
    $db->disconnect();
*  Закрывает соединение с базой данных. Хотя PHP автоматически закрывает соединение при завершении скрипта, рекомендуется закрывать его вручную, когда оно больше не нужно, для освобождения ресурсов.

Важные замечания:

•  Безопасность: Всегда используйте подготовленные выражения (prepared statements) с плейсхолдерами и привязкой значений (bindValue()) для защиты от SQL-инъекций. Никогда не подставляйте данные напрямую в SQL-запросы.
•  Валидация: Используйте правила валидации для проверки данных перед вставкой или обновлением, чтобы обеспечить соответствие данных требованиям вашего приложения.
•  Логирование: Настройте логирование ошибок, чтобы можно было отслеживать проблемы с базой данных.
•  Транзакции: Используйте транзакции для группировки нескольких операций, чтобы обеспечить целостность данных.
•  Обработка ошибок: Всегда оборачивайте код, работающий с базой данных, в блоки try...catch, чтобы обрабатывать возможные исключения и предотвращать аварийное завершение скрипта.
•  Типы данных: Будьте внимательны к типам данных, используемым в SQLite. Используйте правильные типы данных для столбцов таблицы и для значений, которые вы вставляете или обновляете.

Этот класс предоставляет удобный и безопасный способ работы с базами данных SQLite в PHP. Следуйте этой инструкции и рекомендациям, чтобы использовать его эффективно и предотвратить возможные проблемы.
